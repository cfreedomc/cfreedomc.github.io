<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-7-Dubbo高可用]]></title>
    <url>%2F2018%2F05%2F14%2F7Dubbo%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本篇主要介绍Dubbo的高可用功能,主要包含注册中心异常,Dubbo负载均衡以及在高并发以及网络错误下Dubbo提供的解决方案; zookeeper宕机和dubbo直连 zookeeper宕机 当消费者通过zookeeper找到提供者并成功调用后,如果在此刻zookeeper宕机是不会影响连接的,因为会存在本地缓存,消费者通过本地缓存直接调用提供者 dubbo直连 指定消费者引用的url可以进行dubbo直连12@Reference(url = &quot;127.0.0.1:28080&quot;)UserService userService; ps:zookeeper宕机后,消费者是可以继续调用的,因为有本地缓存dubbo是支持直连的 Dubbo的负载均衡 dubbo的负载均衡类型 Random LoanBalance 基于权重随机负载均衡 根据权重随机 RoundRobin LoadBalance 基于权重的轮询负载均衡 在轮询基础上增加权重 LeastActive LoadBalance 最少活跃数负载均衡 调用延迟最低的服务 ConsistentHash LoadBalance 一致性Hash 根据Hash值决定调用机器 权重的配置 消费者配置 123456-- 接口级别&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;-- 方法级别&lt;dubbo:reference interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:reference&gt; 提供者配置 123456-- 接口级别&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;-- 方法级别&lt;dubbo:service interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:service&gt; 服务降级 服务降级概念 当服务器访问量巨大时,无法正常的完成所有服务的响应,可以通过简单处理或关闭服务器中某些不重要的服务,来满足核心业务的高可用; 服务降级类型 mock=force:Return+null 直接在消费者端,强制对某个服务返回null; mock=fail:Return+null 需要调用提供者,当提供者返回失败时(超时等情况)返回null; 服务降级操作 在dubbo的监控系统中可以设置 屏蔽:mock=force 容错:mock=fail 服务容错 概念 服务调用错误后的处理手段； 服务容错类型 Failover Cluster 失败自动切换重试其他服务器； Failfast Cluster 快速失败，只发起一次，适合于非幂等性操作； Failsafe Cluster 失败吞掉异常，忽略，但在审计日志中展现； Failback Cluster 失败自动重试； Forking Cluster 并行调用，一次成功则成功； Broadcast Cluster 串行调用，全成功则成功； Hystrix整合 待续]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-6-Dubbo配置细节介绍]]></title>
    <url>%2F2018%2F05%2F10%2F6Dubbo%E7%9A%84%E7%BB%86%E8%8A%82%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文主要介绍了Dubbo主要的细节属性配置以及相关配置的优先级等情况; 配置文件的优先级在dubbo属性配置中 -D的直接加载是优先级最高的 随后是xml格式的dubbo(在这里xml格式的dubbo.xml是等价于spring boot里的application.properties的) 最后是dubbo.properties文件启动时检查该功能主要是用于当没有提供者出现,消费者端也可以模拟启动12345678910#消费端不检查某个服务dubbo.reference.com.foo.BarService.check=false#消费端引用统一不检查dubbo.reference.check=falsedubbo.consumer.check=false#注册中心不检查,#官方:关闭注册中心启动时检查 (注册订阅失败时报错)#实际操作,一般都会检查不断重连dubbo.registry.check=false 超时设置 timeout属性超过超时时间会认为连接失败,主要的是要了解配置超时属性的优先级(如timeout,retries, loadbalance, actives等属性) 细粒度高的设置优先 细粒度相同,消费端优先(消费端都不介意,提供者就不要多BB了) 重试次数retries重试次数注意点: 如果设置3,其真实重试次数就是3+1,最开始的一次不计入总次数中 支持重试的服务要求其操作是幂等的操作,这点很重要,如是insert操作等是不推荐重试 如果有提供者集群,dubbo默认配置会调用2次失败后切换版本控制可以通过在service和reference中配置version,可以约定提供者和消费者的调用版本 stub本地存根链接存根的目的:希望消费者在调用服务时做出自己的一点贡献,比如常用的参数校验等情况,保证参数正常后再真正的调用远程的服务配置:1&lt;dubbo:service interface=&quot;com.foo.BarService&quot; stub=&quot;com.foo.BarServiceStub&quot; /&gt; 存根编写的注意事项: Stub 必须有可传入 Proxy 的构造函数 在 interface 旁边放一个 Stub 实现，它实现 BarService 接口，并有一个传入远程 BarService 实例的构造函数12345678910111213141516171819package com.foo;public class BarServiceStub implements BarService &#123; private final BarService barService; // 构造函数传入真正的远程代理对象 public (BarService barService) &#123; this.barService = barService; &#125; public String sayHello(String name) &#123; // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等 try &#123; return barService.sayHello(name); &#125; catch (Exception e) &#123; // 你可以容错，可以做任何AOP拦截事项 return &quot;容错数据&quot;; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-5-Dubbo配置方式介绍]]></title>
    <url>%2F2018%2F05%2F04%2F5Dubbo%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文主要介绍了Dubbo主要支持的配置类型,并作出简单的事例以及分析; 配置类型Dubbo主要提供了4种配置方式,分别是以下: xml配置 属性配置 API配置 注解配置 细节可以查询dubbo官方文档介绍:dubbo官网链接 四种配置方式xml方式 配置前置条件(dubbo文档链接) 创建dubbo.*.xml配置文件 程序启动加载对应xml的配置文件 .xml举例1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt; &lt;dubbo:application name=&quot;hello-world-app&quot; /&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt; &lt;dubbo:service interface=&quot;org.apache.dubbo.demo.DemoService&quot; ref=&quot;demoServiceLocal&quot; /&gt; &lt;dubbo:reference id=&quot;demoServiceRemote&quot; interface=&quot;org.apache.dubbo.demo.DemoService&quot; /&gt; &lt;/beans&gt; 属性方式 配置前置条件 创建dubbo.properties配置文件 spring boot会自动读取properties文件内容 .properties举例123dubbo.application.name=foodubbo.application.owner=bardubbo.registry.address=10.20.153.10:9090 API方式 配置前置条件 创建ConfigClass或在boot的main函数编写 举例123456789101112131415161718// 服务实现XxxService xxxService = new XxxServiceImpl(); // 当前应用配置ApplicationConfig application = new ApplicationConfig();application.setName(&quot;xxx&quot;); // 连接注册中心配置RegistryConfig registry = new RegistryConfig();registry.setAddress(&quot;10.20.130.230:9090&quot;);registry.setUsername(&quot;aaa&quot;);registry.setPassword(&quot;bbb&quot;); // 服务提供者协议配置ProtocolConfig protocol = new ProtocolConfig();protocol.setName(&quot;dubbo&quot;);protocol.setPort(12345);protocol.setThreads(200); 注解方式 配置前置条件 启动Application增加@EnableDubbo 举例123@Service(timeout = 1000)@Componentpublic class UserServiceImpl implements UserService &#123; 配置方式比较配置能力比较 xml: 优势:所有的功能都能通过xml的方式进行配置,如方法级别的timeout等 缺点: 需要专门编写xml文件,编写相对繁琐 就算不整合spring boot,原有spring也支持这种方式配置 效率低 属性: 优势:统一配置 缺点:仅用于缺省配置情况加多 注解: 优势:方便 缺点:不支持方法级别的配置,效率低 API: 优势:配置形式清楚,所有配置都支持,效率高 缺点:配置比xml更加繁琐使用场景推荐 xml方式 用于普通服务提供方或消费方(日常使用) 属性方式: 多用于缺省配置(公共内容) API方式: API 仅用于 OpenAPI, ESB, Test, Mock 等系统集成，普通服务提供方或消费方，请采用XML 配置方式使用 Dubbo 注解方式: dubbo2.5.7支持,适用于普通服务提供方或消费方;]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
</search>
