<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot使用系列-多数据源]]></title>
    <url>%2F2019%2F02%2F10%2FSpring%20Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[在很多系统的应用中我们不可避免的需要用到多数据源的情况,如果用最原始的jdbc当然是可以实现的,但是在现在高度使用spring家族的前提下如何使用spring boot结合多数据源值得关注,所以这边进行了简单的记录; 多数据源概述在很多系统的应用中我们不可避免的需要用到多数据源的情况,如果用最原始的jdbc当然是可以实现的,但是在现在高度使用spring家族的前提下如何使用spring boot结合多数据源值得关注,所以这边进行了简单的记录; 多数据源配置 去除spring boot的自动配置 12345@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class, JdbcTemplateAutoConfiguration.class&#125;)public class Application &#123; ...&#125; 自定义数据源 123456789101112131415161718192021222324252627282930313233343536@Bean@ConfigurationProperties(&quot;wy.datasource&quot;)public DataSourceProperties wyDataSourceProperties()&#123; return new DataSourceProperties();&#125;@Beanpublic DataSource wyDataSource()&#123; DataSourceProperties dataSourceProperties=wyDataSourceProperties(); System.out.println(&quot;wy dataSource: &#123;&#125;&quot;+dataSourceProperties.getUrl()); return dataSourceProperties.initializeDataSourceBuilder().build();&#125;@Bean@Resourcepublic PlatformTransactionManager wyTxManager(DataSource wyDataSource)&#123; return new DataSourceTransactionManager(wyDataSource);&#125;@Bean@ConfigurationProperties(&quot;zy.datasource&quot;)public DataSourceProperties zyDataSourceProperties()&#123; return new DataSourceProperties();&#125;@Beanpublic DataSource zyDataSource()&#123; DataSourceProperties dataSourceProperties=zyDataSourceProperties(); System.out.println(&quot;zy dataSource: &#123;&#125;&quot;+dataSourceProperties.getUrl()); return dataSourceProperties.initializeDataSourceBuilder().build();&#125;@Bean@Resourcepublic PlatformTransactionManager zyTxManager(DataSource zyDataSource)&#123; return new DataSourceTransactionManager(zyDataSource);&#125; 配置文件 1234567wy.datasource.url=jdbc:mysql://localhost:3306/hrwy.datasource.username=rootwy.datasource.password=123456zy.datasource.url=jdbc:mysql://localhost:3306/testzy.datasource.username=rootzy.datasource.password=123456 多数据源事务使用 需要对应在使用配置value1234@Transactional(value = &quot;zyTxManager&quot;)public void test()&#123; ...&#125;]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程-1-内存模型]]></title>
    <url>%2F2018%2F11%2F06%2F1.JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-1-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[本篇主要介绍了在Java虚拟机中的内存模型的情况以及基本的内存使用流程; 1.什么是Java内存模型 Java内存模型又称JMM(Java Memory Model),是Java虚拟机为了屏蔽平台和硬件实现java并发能力的一致性; 作用: 规范了如何利用共享变量; Java的内存模型 Java中的内存模型主要分为堆和栈; 堆:存放共享变量,对象的真实存放位置; 栈:存放本地变量,对象的引用等;2.CPU的内存模型 CPU访问速度: 由于CPU的运行速度和访问主内存的速度相差非常多的量级,所以硬件设计师设计了一个高速缓存,来处理CPU速度和内存速度不一致的问题; 内部寄存器&gt;&gt;高速缓存&gt;&gt;&gt;&gt;&gt;内存 运行原理: 读:当CPU需要用到内存中内容时,会先将其读到缓存中,在读取; 写:CPU会先写到缓存中,最后在同步到主内存;3.Java内存模型运行 Java内存的抽象图 Java内存模型执行过程]]></content>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL系列-6-索引使用原理1]]></title>
    <url>%2F2018%2F11%2F04%2F6.MySQL%E7%B3%BB%E5%88%97-6-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇主要介绍MySQL中关于索引使用的原理介绍,主要包含覆盖索引,最左前缀原理,索引下推; 覆盖索引覆盖索引概念从之前InnoDB的索引结构可以发现,如果是通过非主键索引进行搜索时,需要进行回表的操作,而如果我们查询结果只需要ID主键,这时就不需要回表,因为在非主键索引树中已经”覆盖”了查询的需求; 覆盖索引好处由于覆盖索引的方式减少了一次搜索,显著的提高了性能,是一种常用的性能优化手段 举例 简单模型 表中主键是ID,非主键索引是k12-- 覆盖索引select ID from table where k=?; 业务举例 如果有一张客户表,其中有主键id,身份证id_card,用户名name,年级age;12345678910CREATE TABLE `tuser` ( `id` int(11) NOT NULL, `id_card` varchar(32) DEFAULT NULL, `name` varchar(32) DEFAULT NULL, `age` int(11) DEFAULT NULL, `ismale` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `id_card` (`id_card`), KEY `name_age` (`name`,`age`)) ENGINE=InnoDB 此时表中已经有了id_card的索引,但是如果有一个高频需求是通过id_card搜索name的话,这样如果建立一个id_card和name的联合索引,就不需要回表,直接通过索引树就可以返回name了 最左前缀原则承接上面覆盖索引的优化方式而言,我们立马也是有个疑问,就是为了覆盖索引,联合索引是有必要的,那么这样下去岂不是要建立很多索引,这里就要引出最左前缀原则; 最左前缀原则概念即对于联合索引而言,只要满足最左前缀就可以利用索引来加速搜索,这个最左前缀可以是联合索引的最左N个字段,也可以使最左字符串字段的M个字符 为何可以有这个原则,是因为B+树的结构,会按照顺序排列索引,所以可以从最左定位索引位置 最左前缀原则举例我们继续用上面的tuser表,建立(name,age)的联合索引,只要条件满足”张三%”或”张%”都能利用到联合索引 基于最左前缀原则优化 将高频查询字段放在联合索引的最左边 这样做的好处是如果有该联合索引,当出现联合索引(a,b)时,在搜索a字段无需单独建立一个索引a,可以通过该联合索引快速查询; 将空间占用大的放在联合索引最左边 就好比name,age的联合索引,如果name和age的查询权重一致,也就是必须再建立其中一个的单独索引,此刻建立使用联合索引(name,age)和索引age的方式,因为相比name的age占用的空间比较小 索引下推索引下推概念索引下推(index condition pushdown)是可以在索引遍历过程中,先对索引中包含的字段做判断,直接过滤掉不满足的条件,减少回表次数(MySQL5.6后引入) 索引下推举例还是以上表举例,我们有(name,age)的联合索引,现在有以下的查询语句1select * from tuser where name like &apos;张 %&apos; and age=10 and ismale=1; 首先是根据最左前缀原则可以查到索引”张”开头的,随后会出现如下情况 在5.6之前会直接回表查询 5.7之后会先判断age是否满足等于10 索引实战思考题,有以下表结构12345678910CREATE TABLE `geek` ( `a` int(11) NOT NULL, `b` int(11) NOT NULL, `c` int(11) NOT NULL, `d` int(11) NOT NULL, PRIMARY KEY (`a`,`b`), KEY `c` (`c`), KEY `ca` (`c`,`a`), KEY `cb` (`c`,`b`)) ENGINE=InnoDB; 由于历史原因,有联合主键,同时有了索引c,那么为何还要创建ca,cb呢,创建人表示因为有以下的需求:12select * from geek where c=N order by a limit 1;select * from geek where c=N order by b limit 1; 解答:]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL系列-5-索引基础]]></title>
    <url>%2F2018%2F10%2F31%2F5.MySQL%E7%B3%BB%E5%88%97-5-%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本篇主要介绍MySQL中关于索引的底层结构以及InnoDB的索引基础概念; 索引的概念索引的目的为了提高数据查询的效率,像书的目录 索引的结构索引的储存结构常见的有以下三种:哈希表,有序数组和搜索树 哈希表 概念: 是以键-值(key-value)存储数据的结构,只要输入key,就返回对应key的value值,哈希的思路就是把值放在数组里,用哈希函数把key换成一个确定的位置;但哈希函数在多个key可能返回同一个位置,这个时候在这个位置上就会拉去出一个链表; 下图为以ID_card查找name的哈希结构的索引结构图 哈希结构优缺点 优点:支持快速的增删 缺点:结构无序,区间查询速度很慢(必须全部扫描) 使用场景 等值查询,即直接”= v”的场景 有序数组 概念: 有序数组我们都很熟悉,就是将索引递增的存入数组中的结构 如下图所示 有序数组的优缺点: 优点:因为有序,所以可以快速的进行等值以及区间查询 缺点:如果需要对数组进行改动,那么代价就很大,在数组中间插入记录则需挪动后面所有记录; 使用场景: 有序数组索引只适用于静态存储引擎 搜索树 概念: 二叉树的每个节点的左儿子小于父节点,父节点又小于右儿子 下图为二叉树的结构 搜索树的优缺点 优点:,查询和更改都快 缺点:二叉搜索树的由于索引不只要写入内存,还要写入磁盘,每一层都要写入磁盘交互,而磁盘读取数据库寻址需要10ms左右,所以对于很大数据量的表,用二叉树存储太慢,所以退而其次的使用多叉树的结构; 使用场景 N叉树读写的性能优势以及适配磁盘的访问木事,基本广泛应用在数据库引擎; InnoDB索引模型由于在Mysql中我们主要使用InnoDB作为主要的搜索引擎,所以以下都以InnoDB介绍 B+树B+树是二叉树的一种变形,其优势使得在一个内存页中可以存储更多的key,具体的B+树结构就不在这里展开了; InnoDB索引特点InnoDB中索引类型主要会区分:主键索引以及非主键索引两种; 主键索引 主键索引的叶子节点存放的是整行数据,被称为聚簇索引(clustered index) 非主键索引 非主键索引叶子节点存放的是主键索引的值,所以也成为二级索引( secondary index) 举例:如现在有主键索引ID和非主键索引k,其结构如下图 索引的流程 由于如上图结构的存在,所以当我们使用k索引进行查询时,会先从k的索引树先查询到主键索引值,再通过主键索引查询到对应行数据(这个过程称之为回表) 所以在应用中应该尽量使用主键查询; 索引的维护 B+树问题 由于B+树为了维持索引的有序性,每次插入新值都需要维护,如果插入的ID&gt;current.Max直接在后面接索引就可以,但是如果出现插入的ID&lt;current.Max时,就需要将所以大于插入值得索引值后移,在后移过程中可能出现当前索引页满了需要扩张的情况,那么这样开销就更为大了; 主键索引建议 所以由于上面的问题,工作中会发现主键索引一般会用int且自增,这样的好处有两点 永远在最后插入新数据,不用担心B+树的格外开销 使用int时非主键索引的叶子节点存放的主键索引就小,自然占用空间就小 格外说明: 所以什么时候会用业务字段作为索引,一般会满足以下两个条件 只有一个索引 该索引是唯一索引 如果不满足以上条件,建议还是按照主键索引的玩法去做 索引实战思考问题:直接删除非主键索引和删除主键索引有何问题? 解答:删除非主键索引没问题,但是删除主键索引会使整个表的索引都没用,本质就是会将整个表进行重建;]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL系列-4-事务隔离]]></title>
    <url>%2F2018%2F10%2F26%2FMySQL%E7%B3%BB%E5%88%97-4-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[本篇主要介绍MySQL中事务隔离以及关于隔离级别原理和优化的认识; 事务隔离Isolation介绍事务隔离的意义即在多个事务之间,其操作造成数据可见性的问题,主要会出现以下几种情况: 脏读(dirty read) 不可重复读(non-repeatable read) 幻读(phantom read) 事务隔离的意义是为了处理以上情况并且用适当的隔离级别处理相对应的业务问题; 事务隔离级别根据事务间的关系SQL标准总结了事务的隔离级别,包括以下内容: 读未提交(read uncommitted) 一个事务还没提交时,其变更能被其他事务看到; 直接返回要读的值; 读提交(read committed) 一个事务提交后,其变更能被其他事务看到; 每一条SQL开始执行时,创建视图; 可重复读(repeatable read) 一个事务执行中看到的数据,总跟这个时候启动时看到的数据一致; 事务启动时,创建视图; 串行化(serializable) 对于同一行记录,”写”和”读”都进行加锁,当读写锁冲突时,后访问的事务必须等前一个事务执行完成,才能继续执行; 串行执行; 事务隔离级别举例简单举例 事务A 事务B 启动事务查询结果为1 启动事务 查询结果为1 将1改成2 查询得到值v1 提交事务B 查询得到值v2 提交事务A 查询得到值v3 读未提交: v1-2 ,v2-2, v3-2 可以读到事务B没有提交的操作,所以v1读到值直接是2; 读已提交:v1-1,v2-2,v3-2 只能读到提交事务数据,所以v1是1; 可重复读:v1-1,v2-1,v3-2 可重复读的特点就是要保证事务内数据与启动这一致,所以v1和v2都是1 串行化:v1-1,v2-1,v3-2 事务B执行”1–&gt;2”时由于事务A已经读过该行,会被锁住,直到事务A提交后,事务B才能继续执行; ps:当Oracle迁移到MySQL,为了保证数据库隔离级别一致,需要将MySQL设置成”读提交”,查询和配置1234567891011mysql&gt; show variables like &apos;transaction_isolation&apos;;+-----------------------+----------------+| Variable_name | Value |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+ 业务场景在这里举出一个需要”可重复读”的场景 表 账务余额表 账务余额变动流水表 需求 验证本月期初到当前余额差值是否等于金额流水变化合计; 思考 此时我们会发现,在校验过程中交易还是会不断产生的,如果使用隔离级别是”可重复读”,你就不需要担心其他事务对你这次操作的影响了; 事务隔离的实现实现原理这里还是以”可重复读”举例说明原理,在MySQL中,每条记录在更新的时候都会同时记录一条回滚操作,我们可以看下面的例子 操作 开启不同事务将值进行如下更新:1–&gt;2–&gt;3–&gt;4 数据库操作 更新数据的同时生成以下内容 回滚段 对应事务的视图 A,B,C 分析 正是因为在开启事务的同时也创建了对应这个事务时刻的视图,所以对于每个事务来说,只是去处理视图里的内容,这也是数据库的多版本并发控制(MVCC); 潜在风险 问题 在上面的原理中我们不难发现,在每个事务开启的时候都会生成回滚段以及视图,如果事务小还好,那么如果出现长事务,这些对应事务存在的回滚段和视图是否会成为占用内存的大户呢? 解答 答案是肯定会占用的,分析其原因就是首先要了解,这些回滚日志以及视图何时被删除,答案是在不需要的时候才删除,系统会判断当没有事务再需要用到这些数据时,才会被删除,那么就是如果存在一个长事务,那么其对应的数据就会一直保留到这个事务的结束,大量占用内存. 事务的启动方式避免无意长事务问题正是因为在长事务存在潜在风险,所以我们要做的就是如何避免使用长事务 显示启动事务语句,start transaction,commit和rollback; 将set autocommit=1,开启线程的自动提交; 优化特定场景的长事务作为开发来说,对于一个需要频繁使用事务的业务,不希望多次开启和提交事务,所以为了解决再次执行begin事务的开销,可以通过commit work and chain的方式提交事务并自动开启下一次事务来省去再次执行begin的开销;ps:可以查询长事务1select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL系列-2-更新语句执行介绍]]></title>
    <url>%2F2018%2F10%2F16%2F2.MySQL%E7%B3%BB%E5%88%97-2-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[本篇主要介绍MySQL中更新语句的执行流程,并且引出了最为重要的两个日志模块redolog和binlog,简单的介绍了其作用以及在更新语句中扮演的角色; 更新语句执行顺序更新语句的执行顺序仍然是遵循查询语句的执行流程的(具体流程查看系列1即可),但是在细节上又有少许不同; 连接器:连接数据库操作一致; 查询缓存:此时更新语句会清空缓存; 分析器:分析该语句的词法正确性; 优化器:确定优化方式; 执行器:执行sql语句 与查询流程相区别的是更新流程会记录两个日志模块: redolog(重做日志) binlog(归档日志) WAL技术为何要在介绍更新的日志前先介绍WAL技术,通过以下说明就知道了;WAL全称Write-Ahead Logging(预写日志系统) 本质:就是先写日志,再写磁盘的方案; 好处: 是对于非内存数据库而言,磁盘I/O操作是数据库效率的瓶颈,在相同数据量下,采用WAL日志的数据库系统在事务提交时,磁盘写操作只有传统的回滚日志的一盘大小,大大提高了数据库磁盘I/O操作效率,从而提高数据库性能; Redo Log概念redolog是在innoDB引擎中才有的日志模块,其有一个固定大小的日志空间,当有一条记录需要更改时,InnoDB引擎会先把记录写到redolog里并更新内存,本次更新就算完成了,此外InnoDB一起宁会在适当时候,将redolog中的操作更新到磁盘中; redolog操作方式 假定配置了一组4个文件,每个为1GB作为redolog空间,下图中writepos为日志记录位置,checkpoint为擦拭位置也就是写磁盘的位置 若writepos追上checkpoint,表示日志内存满了,这个时候就需要停止新的更新,优先擦拭记录; 作用 redolog的方式使得InnoDB有了crash-safe的能力,哪怕数据库发生异常重启,已经发生的操作也已经存入内存(redolog)不会受到影响 Bin Log概念binlog是专属于Server层的日志模块,也称归档日志,其记录的主要功能通过和redo log比较来表现: redolog是InnoDB引擎特有的,binlog是MySQL的Server层实现的,所有引擎都可以使用 redolog是物理日志,记录了”做了什么修改”,binlog是逻辑日志,记录语句的原始逻辑”给ID=2这一行c字段加1” redolog是循环写,空间固定会用完,而binlog是追加写入,不会覆盖以前日志; 作用binlog的逻辑记录和追加方式,使得数据库可以通过其进行回退操作; 执行器的日志流程语句1mysql&gt; update T set c=c+1 where ID=2; 执行流程 执行器先找引擎取ID=2的行,由于ID是主键,引擎直接用树搜索找到改行,如果ID=2这行所在数据页在内存中,则直接返回给执行器,反之则从磁盘读入内存然后返回; 执行器对返回的该行数据的对应值+1,得到新行数据,再调用引擎接口写入新数据; 引擎将这行新数据更新到内存中,同时将这个更新操作记录到redolog里,此时redolog处于prepare状态,然后告知执行器执行完成了,随时可以提交事务; 执行器生成这个操作binlog,并将binlog写入磁盘; 执行器调用引擎提交事务接口,引擎将redolog改成commit状态,更新完成; 两阶段提交设计问题的抛出在上面的update的语句执行流程可以发现,redolog会先进入prepare状态,然后写binlog最后提交事务使得redolog进行commit,那么为什么要这么去设计? 数据写入和恢复 写入写入就是按照上面说的依照redolog的模式,先写内存再写硬盘的方式; 恢复当我们要进行恢复数据库时,会先找到最近的一次全量备份点,随后从备份时间开始,从备份的binlog中依次去除,重放到需要恢复的时刻; 思考我们发现redolog和binlog是两个独立的动作,但是它们又必须保持动作一致,如果其中有一个执行成功另一个失败则会在恢复数据时造成可怕的影响,我们来举例看一下: 先写redolog后写binlog,当我们在写好redolog时(即某个update语句已经生效并入库),此时数据库crash导致binlog没有记录,这会使得我们在恢复数据时没有恢复该update操作,使得数据不一致; 先写binlog后写redolog,如果在binlog写完后数据库crash会导致恢复数据时,恢复一条根本没有执行的语句,使得数据不一致; 所以为了保证一致性,通过这种两阶段提交的设计是非常有必要的; 本节建议 保证redolog的crash-safe能力,需要将innodb_flush_log_at_trx_commit这个参数设置为1,保证每次事务的redolog都执行持久化到硬盘,使得MySQL异常重启之后数据不丢失; 保证binlog可用性,sync_binlog=1,表示每次事务的binlog都持久化到硬盘,MySQL异常重启后binlog不丢失;]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL系列-1-查询语句执行介绍]]></title>
    <url>%2F2018%2F10%2F11%2F1.MySQL%E7%B3%BB%E5%88%97-1-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[本篇主要介绍MySQL中查询语句的执行流程,主要包含连接器,查询缓存,分析器,优化器,执行器; 一条sql查询语句是如何执行的mysql逻辑架构图mysql主要可以分为Server层和存储引擎层这两层； Server层主要层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySql的大多数核心服务功能，以及所有的内置函数（如日期，时间，数学和加密函数等），所有跨存储引擎的功能都在这实现，比如存储过程，触发器，视图等; 存储引擎层负责数据的存储和提取，其架构模式是插件式的，支持InnoDB，MyISAM，Memory等多个存储引擎(InnoDB为默认引擎). Server层介绍连接器 简介： 连接器负责跟客户端建立连接,获取权限,维持和管理连接. 触发点: 当触发于mysql数据库的连接时,会调用连接器如 1mysql -h$ip -P$port -u$user -p 细节:在完成经典tcp握手后,连接器就开始认证你的身份,身份认证主要有以下两点: 用户名密码验证; 通过权限表查出你拥有权限; 连接类型: 短连接:每次执行完很少几次查询就断开连接,下次查询再重新建立; 长连接:连接成功后,如果客户端持续请求,则一直使用同一个连接; 连接器思考: 长连接一直保持,会造成连接对象长期占用内存,若不断开连接无法释放,处理方法: 定期断开长连接; mysql5.7及以上可以在执行较大操作后,执行mysql_reset_connection重新初始化连接资源(该情况无需重新验证连接信息); 查询缓存 简介: 连接建立后,查询语句会执行第二步,查询缓存,将查询语句作为key,查询是否有对应value返回; 查询缓存思考: 直接跳至思考,是因为不建议使用查询缓存功能,mysql8.0版本已经删除该功能,那为何不建议呢? 因为查询缓存的缓存其实在mysql中会出现频繁更新情况,如果有对表出现更新操作,缓存就会失效,这会使缓存的命中率很低,估计只能试用某些业务静态表了; 分析器 简介: 这是执行语句第三步,分析器负责解析SQL语句 执行内容: 识别sql内容,分析是何种语句,表明,列名等对应; 识别确定语句后,进行词法分析,分析语句是否满足mysql语法规范 错误举例:123mysql&gt; elect * from t where ID=1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;elect * from t where ID=1&apos; at line 1 优化器 简介: 这是执行语句第四部,在分析完sql语句后,决定如何执行sql,如索引选择等; 举例: 1mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 该语句先取t1的c=10的再操作接下来的,也可以先取t2中d=20的,虽然最后逻辑一样,但是由于操作顺序不一样其执行效率也不有不同; 执行器 简介: 这是执行语句最后一步,开始执行语句,执行前要先判断目前连接是否有执行表权限; 举例: 1mysql&gt; select * from T where ID=10; 调用InnoDB引擎借口取这个表第一行,判断ID是否10,不是跳过,是则存在结果集中; 调用引擎接口取下一行,重复判断直至结束; 将结果集返回客户端 查看: 可以通过慢查询日志rows_examined字段了解该语句执行过程中扫描了多少行(该值是执行器每次调用引擎获取数据行时累加);]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-7-Dubbo高可用]]></title>
    <url>%2F2018%2F05%2F14%2F6.Dubbo%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本篇主要介绍Dubbo的高可用功能,主要包含注册中心异常,Dubbo负载均衡以及在高并发以及网络错误下Dubbo提供的解决方案; zookeeper宕机和dubbo直连 zookeeper宕机 当消费者通过zookeeper找到提供者并成功调用后,如果在此刻zookeeper宕机是不会影响连接的,因为会存在本地缓存,消费者通过本地缓存直接调用提供者 dubbo直连 指定消费者引用的url可以进行dubbo直连12@Reference(url = &quot;127.0.0.1:28080&quot;)UserService userService; ps:zookeeper宕机后,消费者是可以继续调用的,因为有本地缓存dubbo是支持直连的 Dubbo的负载均衡 dubbo的负载均衡类型 Random LoanBalance 基于权重随机负载均衡 根据权重随机 RoundRobin LoadBalance 基于权重的轮询负载均衡 在轮询基础上增加权重 LeastActive LoadBalance 最少活跃数负载均衡 调用延迟最低的服务 ConsistentHash LoadBalance 一致性Hash 根据Hash值决定调用机器 权重的配置 消费者配置 123456-- 接口级别&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;-- 方法级别&lt;dubbo:reference interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:reference&gt; 提供者配置 123456-- 接口级别&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;-- 方法级别&lt;dubbo:service interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:service&gt; 服务降级 服务降级概念 当服务器访问量巨大时,无法正常的完成所有服务的响应,可以通过简单处理或关闭服务器中某些不重要的服务,来满足核心业务的高可用; 服务降级类型 mock=force:Return+null 直接在消费者端,强制对某个服务返回null; mock=fail:Return+null 需要调用提供者,当提供者返回失败时(超时等情况)返回null; 服务降级操作 在dubbo的监控系统中可以设置 屏蔽:mock=force 容错:mock=fail 服务容错 概念 服务调用错误后的处理手段； 服务容错类型 Failover Cluster 失败自动切换重试其他服务器； Failfast Cluster 快速失败，只发起一次，适合于非幂等性操作； Failsafe Cluster 失败吞掉异常，忽略，但在审计日志中展现； Failback Cluster 失败自动重试； Forking Cluster 并行调用，一次成功则成功； Broadcast Cluster 串行调用，全成功则成功； Hystrix整合 待续]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-6-Dubbo配置细节介绍]]></title>
    <url>%2F2018%2F05%2F10%2F5.Dubbo%E7%9A%84%E7%BB%86%E8%8A%82%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文主要介绍了Dubbo主要的细节属性配置以及相关配置的优先级等情况; 配置文件的优先级在dubbo属性配置中 -D的直接加载是优先级最高的 随后是xml格式的dubbo(在这里xml格式的dubbo.xml是等价于spring boot里的application.properties的) 最后是dubbo.properties文件启动时检查该功能主要是用于当没有提供者出现,消费者端也可以模拟启动12345678910#消费端不检查某个服务dubbo.reference.com.foo.BarService.check=false#消费端引用统一不检查dubbo.reference.check=falsedubbo.consumer.check=false#注册中心不检查,#官方:关闭注册中心启动时检查 (注册订阅失败时报错)#实际操作,一般都会检查不断重连dubbo.registry.check=false 超时设置 timeout属性超过超时时间会认为连接失败,主要的是要了解配置超时属性的优先级(如timeout,retries, loadbalance, actives等属性) 细粒度高的设置优先 细粒度相同,消费端优先(消费端都不介意,提供者就不要多BB了) 重试次数retries重试次数注意点: 如果设置3,其真实重试次数就是3+1,最开始的一次不计入总次数中 支持重试的服务要求其操作是幂等的操作,这点很重要,如是insert操作等是不推荐重试 如果有提供者集群,dubbo默认配置会调用2次失败后切换版本控制可以通过在service和reference中配置version,可以约定提供者和消费者的调用版本 stub本地存根链接存根的目的:希望消费者在调用服务时做出自己的一点贡献,比如常用的参数校验等情况,保证参数正常后再真正的调用远程的服务配置:1&lt;dubbo:service interface=&quot;com.foo.BarService&quot; stub=&quot;com.foo.BarServiceStub&quot; /&gt; 存根编写的注意事项: Stub 必须有可传入 Proxy 的构造函数 在 interface 旁边放一个 Stub 实现，它实现 BarService 接口，并有一个传入远程 BarService 实例的构造函数12345678910111213141516171819package com.foo;public class BarServiceStub implements BarService &#123; private final BarService barService; // 构造函数传入真正的远程代理对象 public (BarService barService) &#123; this.barService = barService; &#125; public String sayHello(String name) &#123; // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等 try &#123; return barService.sayHello(name); &#125; catch (Exception e) &#123; // 你可以容错，可以做任何AOP拦截事项 return &quot;容错数据&quot;; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-5-Dubbo配置方式介绍]]></title>
    <url>%2F2018%2F05%2F04%2F4.Dubbo%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文主要介绍了Dubbo主要支持的配置类型,并作出简单的事例以及分析; 配置类型Dubbo主要提供了4种配置方式,分别是以下: xml配置 属性配置 API配置 注解配置 细节可以查询dubbo官方文档介绍:dubbo官网链接 四种配置方式xml方式 配置前置条件(dubbo文档链接) 创建dubbo.*.xml配置文件 程序启动加载对应xml的配置文件 .xml举例1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt; &lt;dubbo:application name=&quot;hello-world-app&quot; /&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt; &lt;dubbo:service interface=&quot;org.apache.dubbo.demo.DemoService&quot; ref=&quot;demoServiceLocal&quot; /&gt; &lt;dubbo:reference id=&quot;demoServiceRemote&quot; interface=&quot;org.apache.dubbo.demo.DemoService&quot; /&gt; &lt;/beans&gt; 属性方式 配置前置条件 创建dubbo.properties配置文件 spring boot会自动读取properties文件内容 .properties举例123dubbo.application.name=foodubbo.application.owner=bardubbo.registry.address=10.20.153.10:9090 API方式 配置前置条件 创建ConfigClass或在boot的main函数编写 举例123456789101112131415161718// 服务实现XxxService xxxService = new XxxServiceImpl(); // 当前应用配置ApplicationConfig application = new ApplicationConfig();application.setName(&quot;xxx&quot;); // 连接注册中心配置RegistryConfig registry = new RegistryConfig();registry.setAddress(&quot;10.20.130.230:9090&quot;);registry.setUsername(&quot;aaa&quot;);registry.setPassword(&quot;bbb&quot;); // 服务提供者协议配置ProtocolConfig protocol = new ProtocolConfig();protocol.setName(&quot;dubbo&quot;);protocol.setPort(12345);protocol.setThreads(200); 注解方式 配置前置条件 启动Application增加@EnableDubbo 举例123@Service(timeout = 1000)@Componentpublic class UserServiceImpl implements UserService &#123; 配置方式比较配置能力比较 xml: 优势:所有的功能都能通过xml的方式进行配置,如方法级别的timeout等 缺点: 需要专门编写xml文件,编写相对繁琐 就算不整合spring boot,原有spring也支持这种方式配置 效率低 属性: 优势:统一配置 缺点:仅用于缺省配置情况加多 注解: 优势:方便 缺点:不支持方法级别的配置,效率低 API: 优势:配置形式清楚,所有配置都支持,效率高 缺点:配置比xml更加繁琐使用场景推荐 xml方式 用于普通服务提供方或消费方(日常使用) 属性方式: 多用于缺省配置(公共内容) API方式: API 仅用于 OpenAPI, ESB, Test, Mock 等系统集成，普通服务提供方或消费方，请采用XML 配置方式使用 Dubbo 注解方式: dubbo2.5.7支持,适用于普通服务提供方或消费方;]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-4-SpringBoot整合Dubbo]]></title>
    <url>%2F2018%2F04%2F19%2F7.Springboot%E6%95%B4%E5%90%88Dubbo%2F</url>
    <content type="text"><![CDATA[本篇主要介绍基于SpringBoot的dubbo配置方法 前言概述在之前,我们已经用spring的框架整合过Dubbo,但是面对现在流行的Spring Boot其提供了更为便捷的方式将Dubbo整合到系统中去; 去Xml化在Spring Boot中原有dubbo的provider.xml以及consumer.xml等配置都可以在application.properties里面配置 pom.xmlpom.xml统一增加spring boot整合dubbo的jar包12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt; user-boot-provider application.properties 12345dubbo.application.name=user-boot-providerdubbo.registry.address=127.0.0.1:2181dubbo.registry.protocol=zookeeperdubbo.protocol.port=28080dubbo.protocol.name=dubbo 具体服务提供(使用dubbo的@Service) 123456789101112131415import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;import service.UserService;@Service@Componentpublic class UserServiceImpl implements UserService &#123; @Override public String getUserName(String userId) &#123; if (userId.contains(&quot;wy&quot;))&#123; return &quot;cfreedomc&quot;; &#125; return &quot;none&quot;; &#125;&#125; order-boot-consumer application.properties 12345dubbo.application.name=user-boot-providerdubbo.registry.address=127.0.0.1:2181dubbo.registry.protocol=zookeeperdubbo.protocol.port=28080dubbo.protocol.name=dubbo 具体调用服务(通过dubbo的@Reference) 1234567891011121314import com.alibaba.dubbo.config.annotation.Reference;import org.springframework.stereotype.Component;import service.OrderService;import service.UserService;@Componentpublic class OrderServiceImpl implements OrderService &#123; @Reference UserService userService; @Override public String getOrderInfo(String userId) &#123; return userService.getUserName(userId); &#125; }]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-3-Dubbo快速使用]]></title>
    <url>%2F2018%2F04%2F16%2F3.Dubbo%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本篇主要介绍dubbo环境搭建以及配置 注册中心搭建Zookeeper下载下载地址 点击downl–&gt;archive–&gt;下载对应版本 Zookeeper启动 windows中直接cmd中运行 zkService.cmd(会报错,因为没有配置cfg) 配置文件在/conf中有zoo_sample.cfg文件,修改其为zoo.cfg 基于windows要修改zoo.cfg中的目录结构将/tmp/zookeeper修改至windows中存储内容,如../dataZookeeper测试 cmd启动zkService.cmd 在cmd启动zkClient.cmd,发现已经连接上zookeeper 在zkClient中进行简单操作123获取根节点:get /查看当前节点下内容: ls /获取节点内容: get /pointName Dubbo环境搭建 案例结构 user-service-provider dubbo提供者,用于提供用户服务 order-service-consumer dubbo消费者,用于消费用户服务 wangyin-api dubbo的依赖API,公共数据放置,具体参考dubbo官方 引入dubbo依赖,maven仓库找一下 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt;&lt;/dependency&gt; zookeeper客户端 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt; wangyin-api代码编写 编写公用bean User.java 编写接口 UserService OrderServiceuser-service-provider编写 pom.xml中依赖wangyin-api 实现UserServiceImpl 1234567@Componentpublic class UserServiceImpl implements UserService &#123; @Override public String getUserName(String userId) &#123; return &quot;恭喜你调用成功了,from cfreedomc&quot;; &#125;&#125; user-service-provider配置dubbo: provider.xml 在resource中创建spring的配置文件 配置provider.xml内容 1.设置应用dubbo名称 2.设置注册中心地址 3.设置通讯协议以及端口 4.提供服务12345678&lt;dubbo:application name=&quot;user-service-provider&quot;/&gt;&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt;&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;&lt;dubbo:service interface=&quot;com.wangyin.wangyinapi.service.UserService&quot; ref=&quot;userService&quot;/&gt;&lt;!-- 这里直接bean注入,也可以使用commpent-scan扫描 --&gt; ps:1.使用xml的bean注入可以不用在bean上加注解2.如果使用注解,需要增加context:commpent-scan并且注解增加service的name 编写SpringBoot启动程序12345678@SpringBootApplicationpublic class UserServiceProviderApplication &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;&quot;provider.xml&quot;&#125;); context.start(); System.in.read(); // 按任意键退出 &#125;&#125; order-service-consumer编写 同上pom.xml增加wangyin-api的依赖 编写OrderService的实现 123456789@Servicepublic class OrderServiceImpl implements OrderService &#123; @Autowired UserService userService; public void getOrderInfo() &#123; System.out.println(userService.getUserName(&quot;1&quot;)); &#125;&#125; 配置dubbo:consumer.xml 1.配置应用dubbo名称 2.配置注册中心连接 3.配置bean引用 &lt;context:component-scan base-package=”com”/&gt; &lt;dubbo:application name=”order-service-consumer”/&gt; &lt;dubbo:registry address=”zookeeper://127.0.0.1:2181”/&gt; &lt;dubbo:reference id=”userService” interface=”com.wangyin.wangyinapi.service.UserService”/&gt; 编写OrderAplicationApp123456789101112@SpringBootApplicationpublic class OrderServiceConsumerApplication &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext( new String[]&#123;&quot;consumer.xml&quot;&#125;); OrderService orderService = classPathXmlApplicationContext.getBean(OrderService.class); orderService.getOrderInfo(); System.in.read(); &#125;&#125; Dubbo测试 测试前,需要先保证zookeeper的注册中心已启动 先启动user-service-provider 再启动order-service-consumer 查看最后运行结果]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-2-Dubbo介绍]]></title>
    <url>%2F2018%2F04%2F10%2F2.Dubbo%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[本篇主要介绍dubbo是什么以及其主要的特性和组成; Dubbo概念Dubbo是什么Apache Dubbo是一款高性能的Java RPC框架,Dubbo链接 Dubbo特性 Dubbo解决什么问题URL瓶颈 问题: 在没有完全服务化之前,实现服务之间调用仅仅是简单的URL的暴露与调用,但是当服务量越来越大,需要对应暴露的url也就越多,自然配置难度就几何倍的增加,所以需要一个集中管理的方案; 解决方案: 通过服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本 服务间关系复杂 问题: 服务数量的增加,相互之间复杂的调用关系,使得很难人为的去理清楚; 解决方案: Dubbo可以自动的生成依赖关系图; 服务性能监控 问题: 服务的使用仍处于混沌之中,对于服务的性能(调用量,响应时间),权重等问题都无法高效处理; 解决方案: Dubbo有系统的监控以上参数,并且可以动态的改变权重等设置; Dubbo的组成 节点说明 Provider 服务提供方 Consumer 服务消费方 Registry 服务注册与发现的注册中心 Mointor 统计调用次数和时间的监控中心 Container 服务运行容器 步骤说明0:服务容器负责启动,加载,运行服务提供者;1:服务提供者在启动时,向注册中心注册;2:服务消费者在启动时,从注册中心订阅所需服务;3:注册中心返回服务提供者地址列表给消费者,若发生变更,注册中心将基于场链接推送变更数据给消费者;4:服务消费者从提供者地址列表中,基于软负载均衡算法,调用服务;5:服务消费者和提供者,在内存中累计调用次数和调用时间,定时每分钟发送一次统计数据到监控中心; Dubbo架构特点连通性 注册中心负责服务地址的注册与查找,相当于目录服务,服务提供者与消费者只在启动时与注册中心交互,注册中心不转发请求,压力小; 服务提供者向注册中心提供服务,并汇报调用时间到监控中心,此时间不包含网络开销; 服务消费者向注册中心获取服务提供者地址列表,并根据负载算法直接调用提供者,同时汇报调用时间到监控中心,此时间包含网络开销; 注册中心,服务提供者,消费者三者之间是长连接,监控中心不是; 注册中心通过长连接感知服务提供者的存在,服务提供者宕机,注册中心将立即推送事件通知消费者; 注册中心和监控中心全部宕机,不影响已运行的提供者和消费者,消费者在本地缓存了提供者列表; 注册中心和监控中心都是可选的,服务消费者可以直连服务提供者; 健壮性 监控中心宕机不影响使用,但丢失部分采样数据; 数据库宕机,注册中心仍能通过缓存提供服务列表查询,但不能注册新服务; 注册中心对等集群,任意一台宕机,将自动切换到另一台; 注册中心全部宕机,服务提供者和服务消费者仍通过本地缓存通讯; 服务提供者无状态,任意一台宕机,不影响使用; 服务提供者全部宕机后,服务消费者应用将无法使用,并无限次重连等待服务提供者恢复; 伸缩性 注册中心为对等集群,可动态增加机器部署实例,所有客户端将自动发现新的注册中心; 服务提供者无状态,可动态增加机器部署实例,注册中心将推送新的服务提供者信息给消费者;]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo系列-1-分布式系统介绍]]></title>
    <url>%2F2018%2F04%2F02%2F1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本篇主要介绍分布式系统的演化过程; 分布式系统什么是分布式系统？《分布式系统原理范型》定义:分布式系统[distributed system]是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统； 为何要用分布式系统？因为随着互联网的发展，访问量的指数级上升后，原有的系统架构无法满足要求，需要一种新的系统架构解决高并发，高可用的场景；ps：所以所有的程序乃至架构的变革都是因为业务的需要，所以编程都要从业务出发，离开业务的编程，应该是一个笑话； 分布式系统的演化？经典的架构演变图是从单一应用架构–&gt;垂直架构–&gt;分布式架构–&gt;SOA的结果 单一架构单一架构是所有应用都在一个服务器中，功能之间的调用都在内存中即可，如果需要扩展也只能进行横向的复制操作；（即将整个服务器中的应用复制一份到另一个服务器中）；问题：1.应用之间耦合性过大2.负载能力差 垂直架构垂直架构相比于单一架构，其开始在功能上进行优化，将相关性或无相关性的应用拆分部署在不同的服务器上，不仅提高了并发性能，同时也在系统迭代等问题上提供了解决办法；问题：1.要求无相关性，但是现实场景下，是很难有应用之间是无相关的，所以应用之间是需要通讯的，而通讯在垂直应用之间就比较麻烦了；2.服务和前端展示的更新频率不一致，垂直架构还没有做到分离； 分布式服务架构(RPC)RPC[Remote Procedure Call]远程过程调用，是一种进程间的通行方式，是思想不是规范,其是当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键; 流动计算架构(SOA)当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。]]></content>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
</search>
