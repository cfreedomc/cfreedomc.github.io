---
title: MySQL系列-4-事务隔离
date: 2018-10-26
tags: mysql
---
>本篇主要介绍MySQL中事务隔离以及关于隔离级别原理和优化的认识;

<!-- more -->

## 事务隔离Isolation介绍
### 事务隔离的意义
即在多个事务之间,其操作造成数据可见性的问题,主要会出现以下几种情况:
* 脏读(dirty read)
* 不可重复读(non-repeatable read)
* 幻读(phantom read)

事务隔离的意义是为了处理以上情况并且用适当的隔离级别处理相对应的业务问题;

### 事务隔离级别
根据事务间的关系SQL标准总结了事务的隔离级别,包括以下内容:
* 读未提交(read uncommitted)
  * 一个事务**还没提交**时,其变更能被其他事务看到;
  * 直接返回要读的值;
* 读提交(read committed)
  * 一个事务**提交**后,其变更能被其他事务看到;
  * 每一条SQL开始执行时,创建**视图**;
* 可重复读(repeatable read)
  * 一个事务执行中看到的数据,总跟这个时候**启动时**看到的数据**一致**;
  * 事务启动时,创建**视图**;
* 串行化(serializable)
  * 对于同一行记录,"写"和"读"都进行**加锁**,当读写锁冲突时,后访问的事务必须等前一个事务执行完成,才能继续执行;
  * 串行执行;

### 事务隔离级别举例
### 简单举例
| 事务A   | 事务B   | 
|:----|:----|
| 启动事务查询结果为1   | 启动事务   | 
|    | 查询结果为1   | 
|    | 将1改成2   | 
| 查询得到值v1   |    | 
|    | 提交事务B   | 
| 查询得到值v2   |    | 
| 提交事务A   |    | 
| 查询得到值v3   |    | 

* 读未提交: v1-2 ,v2-2, v3-2
  * 可以读到事务B没有提交的操作,所以v1读到值直接是2;
* 读已提交:v1-1,v2-2,v3-2
  * 只能读到提交事务数据,所以v1是1;
* 可重复读:v1-1,v2-1,v3-2
  * 可重复读的特点就是要保证事务内数据与启动这一致,所以v1和v2都是1
* 串行化:v1-1,v2-1,v3-2
  * 事务B执行"1-->2"时由于事务A已经读过该行,会被锁住,直到事务A提交后,事务B才能继续执行;

ps:当Oracle迁移到MySQL,为了保证数据库隔离级别一致,需要将MySQL设置成"读提交",查询和配置
```
mysql> show variables like 'transaction_isolation';

+-----------------------+----------------+

| Variable_name | Value |

+-----------------------+----------------+

| transaction_isolation | READ-COMMITTED |

+-----------------------+----------------+
```

### 业务场景
在这里举出一个需要"可重复读"的场景
* 表
  * 账务余额表
  * 账务余额变动流水表
* 需求
  * 验证本月期初到当前余额差值是否等于金额流水变化合计;
* 思考
  * 此时我们会发现,在校验过程中交易还是会不断产生的,如果使用隔离级别是"可重复读",你就不需要担心其他事务对你这次操作的影响了;

---
## 事务隔离的实现
### 实现原理
这里还是以"可重复读"举例说明原理,在MySQL中,每条记录在更新的时候都会同时记录一条回滚操作,我们可以看下面的例子
* 操作
  * 开启不同事务将值进行如下更新:1-->2-->3-->4
* 数据库操作
  * 更新数据的同时生成以下内容
    * 回滚段
    * 对应事务的视图 A,B,C
* 分析
  * 正是因为在开启事务的同时也创建了对应这个事务时刻的视图,所以对于每个事务来说,只是去处理视图里的内容,这也是数据库的多版本并发控制(MVCC);

![图片](https://i.loli.net/2019/03/04/5c7d2d0cc7835.png)

### 潜在风险
* 问题
  * 在上面的原理中我们不难发现,在每个事务开启的时候都会生成回滚段以及视图,如果事务小还好,那么如果出现长事务,这些对应事务存在的回滚段和视图是否会成为占用内存的大户呢?
* 解答
  * 答案是肯定会占用的,分析其原因就是首先要了解,这些回滚日志以及视图何时被删除,答案是在不需要的时候才删除,系统会判断当没有事务再需要用到这些数据时,才会被删除,那么就是如果存在一个长事务,那么其对应的数据就会一直保留到这个事务的结束,大量占用内存.

## 事务的启动方式
### 避免无意长事务问题
正是因为在长事务存在潜在风险,所以我们要做的就是如何避免使用长事务
* 显示启动事务语句,start transaction,commit和rollback;
* 将set autocommit=1,开启线程的自动提交;

### 优化特定场景的长事务
作为开发来说,对于一个需要频繁使用事务的业务,不希望多次开启和提交事务,所以为了解决再次执行begin事务的开销,可以通过commit work and chain的方式提交事务并自动开启下一次事务来省去再次执行begin的开销;
ps:可以查询长事务
```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

