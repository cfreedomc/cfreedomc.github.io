---
title: MySQL系列-2-更新语句执行介绍
date: 2018-10-16
tags: mysql
---
![图片](http://pl5cg4rhb.bkt.clouddn.com/dubbo7page.png)
>本篇主要介绍MySQL中更新语句的执行流程,并且引出了最为重要的两个日志模块redolog和binlog,简单的介绍了其作用以及在更新语句中扮演的角色;

<!-- more -->
## 更新语句执行顺序
更新语句的执行顺序仍然是遵循查询语句的执行流程的(具体流程查看系列1即可),但是在细节上又有少许不同;
* 连接器:连接数据库操作一致;
* 查询缓存:此时更新语句会清空缓存;
* 分析器:分析该语句的词法正确性;
* 优化器:确定优化方式;
* 执行器:执行sql语句

与查询流程相区别的是更新流程会记录两个日志模块:
* redolog(重做日志)
* binlog(归档日志)

---
## WAL技术
为何要在介绍更新的日志前先介绍WAL技术,通过以下说明就知道了;
WAL全称Write-Ahead Logging(预写日志系统) 
* 本质:就是先写日志,再写磁盘的方案;
* 好处:
  * 是对于非内存数据库而言,磁盘I/O操作是数据库效率的瓶颈,在相同数据量下,采用WAL日志的数据库系统在事务提交时,磁盘写操作只有传统的回滚日志的一盘大小,大大提高了数据库磁盘I/O操作效率,从而提高数据库性能;

---
## Redo Log
### 概念
redolog是在innoDB引擎中才有的日志模块,其有一个固定大小的日志空间,当有一条记录需要更改时,InnoDB引擎会先把记录写到redolog里并更新内存,本次更新就算完成了,此外InnoDB一起宁会在适当时候,将redolog中的操作更新到磁盘中;

### redolog操作方式
* 假定配置了一组4个文件,每个为1GB作为redolog空间,下图中writepos为日志记录位置,checkpoint为擦拭位置也就是写磁盘的位置
* 若writepos追上checkpoint,表示日志内存满了,这个时候就需要停止新的更新,优先擦拭记录;

![图片](http://pl5cg4rhb.bkt.clouddn.com/mysql-2-1.png)

### 作用
* redolog的方式使得InnoDB有了**crash-safe**的能力,哪怕数据库发生异常重启,已经发生的操作也已经存入内存(redolog)不会受到影响

---
## Bin Log
### 概念
binlog是专属于Server层的日志模块,也称归档日志,其记录的主要功能通过和redo log比较来表现:
* redolog是InnoDB引擎特有的,binlog是MySQL的Server层实现的,所有引擎都可以使用
* redolog是物理日志,记录了"做了什么修改",binlog是逻辑日志,记录语句的原始逻辑"给ID=2这一行c字段加1"
* redolog是循环写,空间固定会用完,而binlog是追加写入,不会覆盖以前日志;

### 作用
binlog的逻辑记录和追加方式,使得数据库可以通过其进行回退操作;


---
## 执行器的日志流程
### 语句
```
mysql> update T set c=c+1 where ID=2;
```

### 执行流程
* 执行器先找引擎取ID=2的行,由于ID是主键,引擎直接用树搜索找到改行,如果ID=2这行所在数据页在内存中,则直接返回给执行器,反之则从磁盘读入内存然后返回;
* 执行器对返回的该行数据的对应值+1,得到新行数据,再调用引擎接口写入新数据;
* 引擎将这行新数据更新到内存中,同时将这个更新操作记录到**redolog**里,此时redolog处于prepare状态,然后告知执行器执行完成了,随时可以提交事务;
* 执行器生成这个操作binlog,并将binlog写入磁盘;
* 执行器调用引擎提交事务接口,引擎将redolog改成commit状态,更新完成;

![图片](http://pl5cg4rhb.bkt.clouddn.com/mysql-2-2.png)


---
## 两阶段提交设计
### 问题的抛出
在上面的update的语句执行流程可以发现,redolog会先进入prepare状态,然后写binlog最后提交事务使得redolog进行commit,那么为什么要这么去设计?
### 数据写入和恢复
* 写入
写入就是按照上面说的依照redolog的模式,先写内存再写硬盘的方式;

* 恢复
当我们要进行恢复数据库时,会先找到最近的一次全量备份点,随后从备份时间开始,从备份的binlog中依次去除,重放到需要恢复的时刻;

### 思考
我们发现redolog和binlog是两个独立的动作,但是它们又必须保持动作一致,如果其中有一个执行成功另一个失败则会在恢复数据时造成可怕的影响,我们来举例看一下:
* **先写redolog后写binlog**,当我们在写好redolog时(即某个update语句已经生效并入库),此时数据库crash导致binlog没有记录,这会使得我们在恢复数据时没有恢复该update操作,使得数据不一致;
* **先写binlog后写redolog**,如果在binlog写完后数据库crash会导致恢复数据时,恢复一条根本没有执行的语句,使得数据不一致;

所以为了保证一致性,通过这种两阶段提交的设计是非常有必要的;
## 本节建议
* 保证redolog的crash-safe能力,需要将innodb_flush_log_at_trx_commit这个参数设置为1,保证每次事务的redolog都执行持久化到硬盘,使得MySQL异常重启之后数据不丢失;
* 保证binlog可用性,sync_binlog=1,表示每次事务的binlog都持久化到硬盘,MySQL异常重启后binlog不丢失;



